#include QMK_KEYBOARD_H
#include "raw_hid.h"
#include "split_util.h"
#include "transport.h"
#include "transactions.h"

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

 // Define buffer for the image 512 bytes
 #define IMAGE_CHUNKS 32
 #define CHUNK_SIZE 16
 #define IMAGE_WIDTH 32   // Width of the display
 #define IMAGE_HEIGHT 128 // Height of the display
 #define IMAGE_BYTES_PER_ROW (IMAGE_WIDTH / 8) // 32 pixels / 8 bits per byte = 4 bytes per row

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[0] = LAYOUT(KC_ESC, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_GRV, KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_LBRC, KC_LCTL, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_QUOT, KC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_LBRC, KC_CAPS, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_RSFT, KC_LALT, KC_LGUI, MO(1), KC_SPC, KC_ENT, MO(2), KC_BSPC, KC_RGUI),
	[1] = LAYOUT(_______, KC_BRID, KC_BRIU, _______, _______, AS_TOGG, _______, KC_MRWD, KC_MPLY, KC_MFFD, KC_MUTE, _______, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, KC_GRV, KC_EXLM, KC_AT, KC_HASH, KC_DLR, KC_PERC, KC_CIRC, KC_AMPR, KC_ASTR, KC_LPRN, KC_RPRN, KC_TILD, _______, _______, _______, _______, _______, _______, _______, _______, XXXXXXX, KC_UNDS, KC_PLUS, KC_LCBR, KC_RCBR, KC_PIPE, _______, _______, _______, _______, _______, MO(3), _______, _______),
	[2] = LAYOUT(_______, _______, _______, _______, _______, _______, _______, KC_MRWD, KC_MPLY, KC_MFFD, KC_MUTE, _______, KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, _______, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, XXXXXXX, KC_LEFT, KC_DOWN, KC_UP, KC_RGHT, XXXXXXX, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, _______, _______, KC_PLUS, KC_MINS, KC_EQL, KC_LBRC, KC_RBRC, KC_BSLS, _______, _______, MO(3), KC_LSFT, _______, _______, _______, _______),
	[3] = LAYOUT(XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, RGB_TOG, RGB_HUI, RGB_SAI, RGB_VAI, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, RGB_MOD, RGB_HUD, RGB_SAD, RGB_VAD, _______, _______, _______, _______, _______, _______, _______, _______)
};

#if defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
    [0] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(KC_VOLD, KC_VOLU)  },
    [1] = { ENCODER_CCW_CW(KC_DOWN, KC_UP), ENCODER_CCW_CW(KC_DOWN, KC_UP) },
    [2] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(KC_VOLD, KC_VOLU) },
    [3] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(KC_VOLD, KC_VOLU) },
};
#endif

typedef struct _master_to_slave_t {
    int m2s_data;
} master_to_slave_t;

master_to_slave_t free_ram_state;
master_to_slave_t display_mode_state;

// Define global variables to store CPU usage and free RAM
uint8_t cpu_usage = 0;
uint8_t free_ram = 0;
char version_string[12]; // Enough to hold "255.255.255\0"
uint8_t image_buffer[IMAGE_CHUNKS * CHUNK_SIZE] = {0}; // 512 bytes buffer
bool image_complete = false;

// 0 - default screen
// 1 - print version
// 2 - show hardware information
// 3 - show image
uint8_t display_mode = 0;

void raw_hid_receive(uint8_t *data, uint8_t length) {
    // Ensure the data length is always 32
    if (length == 32) {
        // Display hardware inforamtion
        if (data[0] == 0x2) {
            // Parse CPU usage and free RAM from the data
            cpu_usage = data[1];
            free_ram = data[2];
            display_mode = 2;
        } else if (data[0] == 0x1) {
            // Read version information
            uint8_t major_version = data[1];
            uint8_t minor_version = data[2];
            uint8_t patch_version = data[3];

            // Build the version string
            snprintf(version_string, sizeof(version_string), "%u.%u.%u", major_version, minor_version, patch_version);

            display_mode = 1;
        } else if (data[0] == 0x3) {
            cpu_usage = 0;
            free_ram = 0;
            display_mode = 0;
        } else if (data[0] == 0x4) {
            // Handle image data
            uint8_t chunk_number = data[1];
            if (chunk_number < IMAGE_CHUNKS) {
                // Copy 24 bytes of payload to the correct position in the image buffer
                memcpy(&image_buffer[chunk_number * CHUNK_SIZE], &data[2], CHUNK_SIZE);

                // Check if this is the last chunk
                if (chunk_number == IMAGE_CHUNKS - 1) {
                    image_complete = true;
                    display_mode = 3; // Indicate that the image is ready to be displayed
                }
            }
        }

        // Prepare the response data
        uint8_t send_data[32] = {0x00};
        memcpy(&send_data[1], &data[1], 31);  // Copy data starting from the second byte

        // Send the response
        raw_hid_send(send_data, sizeof(send_data));
    }
}


void render_cpu_usage(void) {
    uint8_t text_height = 8; // Height of the "CPU" text in pixels
    uint8_t total_height = 132; // Total height of the display in pixels
    uint8_t bar_area_height = total_height - text_height; // Height of the area available for the bar
    uint8_t fill_height = (cpu_usage * bar_area_height) / 100;  // Calculate fill height based on CPU usage

    // Render "CPU" text at the bottom
    oled_set_cursor(1, (total_height / 8) - 1); // Set cursor to the bottom row
    oled_write("CPU", false); // Write "CPU" text

    // Render CPU usage bar starting just above the text
    for (uint8_t y = 0; y < bar_area_height; y++) {
        for (uint8_t x = 4; x < 28; x++) {
            bool pixel_on = y < fill_height;
            oled_write_pixel(x, total_height - text_height - y - 7, pixel_on); // Adjusting position by -5
        }
    }
}


void render_free_ram(void) {
    uint8_t _free_ram = (uint8_t)free_ram_state.m2s_data;
    // uint8_t fill_height = (_free_ram * 132) / 100;
    // // Calculate fill height based on free RAM
    // for (uint8_t y = 0; y < 132; y++) {
    //     for (uint8_t x = 16; x < 32; x++) {
    //         oled_write_pixel(x, y, y >= (132 - fill_height));
    //     }
    // }


    uint8_t text_height = 8; // Height of the "CPU" text in pixels
    uint8_t total_height = 132; // Total height of the display in pixels TODO: fix to 128
    uint8_t bar_area_height = total_height - text_height; // Height of the area available for the bar
    uint8_t fill_height = (_free_ram * bar_area_height) / 100;  // Calculate fill height based on CPU usage

    // Render "CPU" text at the bottom
    oled_set_cursor(1, (total_height / 8) - 1); // Set cursor to the bottom row
    oled_write("RAM", false); // Write "CPU" text

    // Render CPU usage bar starting just above the text
    for (uint8_t y = 0; y < bar_area_height; y++) {
        for (uint8_t x = 4; x < 28; x++) {
            bool pixel_on = y < fill_height;
            oled_write_pixel(x, total_height - text_height - y - 7, pixel_on); // Adjusting position by -5
        }
    }
}

// Function to draw the image
void draw_image_from_buffer(void) {
    for (int y_offset = 0; y_offset < (IMAGE_HEIGHT / 8); y_offset++) {
        for (int x = 0; x < IMAGE_WIDTH; x++) {
            uint8_t byte = image_buffer[y_offset * IMAGE_WIDTH + x];

            // Each byte represents 8 vertical pixels
            for (int bit = 0; bit < 8; bit++) {
                int pixel_y = y_offset * 8 + bit; // Y position (0-127)
                bool pixel_state = (byte >> bit) & 0x01; // Extract pixel state (on/off)

                // Write the pixel to the display
                oled_write_pixel(x, pixel_y, pixel_state);
            }
        }
    }
}

bool oled_task_user(void) {
    if (display_mode == 2) {
        if (is_keyboard_master()) {
            oled_clear();
            render_cpu_usage();  // Render CPU usage on master screen
        } else {
            oled_clear();
            render_free_ram();  // Render free RAM on non-master screen
        };
    } else if (display_mode == 1) {
        if (is_keyboard_master()) {
            // Clear the OLED display
            oled_clear();

            // Draw the version string on the OLED display
            oled_write(version_string, false);
        } else {
            oled_clear();
        }
    } else if (display_mode == 3 && is_keyboard_master()) {
        // Only the master displays the image
        oled_clear();
        draw_image_from_buffer(); // Display the received image
    } else {

        // clang-format off
        static const char PROGMEM aurora_art[] = {
            0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1c, 0x08, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x40,
            0xe0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x80,
            0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x80, 0x00, 0xf0, 0x00, 0x00, 0xc0,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x81, 0x00, 0xc0, 0x00, 0xfe, 0x00, 0xfc, 0x00, 0xff, 0x20, 0xff, 0xf0, 0x0f, 0xf0, 0x00, 0xff,
            0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0xf8, 0x00, 0x00, 0xf8,
            0xff, 0x10, 0xff, 0x84, 0xff, 0x60, 0xff, 0x36, 0xff, 0x0f, 0xff, 0x3f, 0x00, 0x5f, 0x00, 0x05,
            0x80, 0x00, 0x80, 0x00, 0xc0, 0x38, 0x00, 0xec, 0xf0, 0x00, 0xfb, 0x80, 0xff, 0xf0, 0xff, 0xef,
            0xff, 0xe8, 0xff, 0x03, 0xff, 0x0c, 0xff, 0x00, 0xff, 0x00, 0x03, 0x00, 0x00, 0xf8, 0x00, 0x80,
            0xff, 0x20, 0xff, 0xd0, 0xff, 0xe0, 0xfe, 0xf8, 0xff, 0xfc, 0xff, 0xff, 0x0f, 0xff, 0x01, 0x3f,
            0xff, 0x00, 0x0f, 0x00, 0x01, 0x00, 0x03, 0x00, 0xfe, 0x80, 0xfe, 0x00, 0xc0, 0xff, 0xc4, 0xfb,
            0xff, 0xfe, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0x07, 0xff, 0x03, 0x3f, 0x00, 0x0f, 0xc0, 0x00,
            0x00, 0x00, 0xb8, 0x00, 0xff, 0x40, 0xbe, 0xf0, 0xff, 0xf1, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff,
            0x1f, 0xff, 0x67, 0x00, 0xef, 0x00, 0x1f, 0x00, 0x00, 0x07, 0x00, 0x00, 0xe0, 0x00, 0xff, 0xf0,
            0xff, 0x88, 0xff, 0xc4, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0x7f, 0x0f, 0xff,
            0x00, 0x07, 0xfe, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0xc0, 0x3f, 0xf8, 0xe7, 0xff,
            0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0x1f, 0x3f, 0x01, 0xff, 0x0b, 0x00, 0xff, 0x00, 0x00, 0x05,
            0x00, 0x00, 0x00, 0xe0, 0x00, 0xf8, 0x60, 0x80, 0xfe, 0xe3, 0xfc, 0xff, 0x1e, 0xff, 0xff, 0x23,
            0xff, 0x09, 0xff, 0x20, 0x00, 0x3f, 0x02, 0x00, 0x00, 0x0f, 0x00, 0x40, 0x00, 0xc0, 0x00, 0xfc,
            0xe0, 0xfc, 0xf0, 0xff, 0xff, 0x7f, 0xfc, 0xff, 0x0f, 0xff, 0x07, 0x1f, 0x00, 0x01, 0x0f, 0x00,
            0x0f, 0x00, 0x81, 0x70, 0x0c, 0xf0, 0x80, 0x00, 0x00, 0xe4, 0xf8, 0xe6, 0x70, 0x3f, 0xcf, 0xff,
            0x1f, 0xff, 0x48, 0xff, 0x0f, 0x00, 0x07, 0x00, 0x00, 0x43, 0x60, 0xf8, 0xf0, 0xfe, 0x38, 0xfe,
            0x00, 0xfc, 0x03, 0x00, 0xc8, 0x72, 0xcf, 0xfc, 0x00, 0x03, 0x0f, 0x01, 0xe0, 0x1c, 0xe0, 0x03,
            0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x06, 0xf9, 0x00, 0x03, 0x00, 0x07,
            0xff, 0x00, 0x10, 0x12, 0xc9, 0xf0, 0xcf, 0xb4, 0x7f, 0x80, 0xe0, 0x1e, 0x01, 0x40, 0x65, 0x5e,
            0xe0, 0x00, 0x00, 0xf0, 0x0c, 0xf0, 0x00, 0x80, 0x7e, 0x01, 0x80, 0x93, 0xfc, 0xc0, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x89, 0x18, 0x2c, 0x46, 0x00, 0x07, 0x21, 0x10, 0x10, 0x80, 0x09, 0x13,
            0x31, 0xbf, 0xff, 0x00, 0x08, 0x1a, 0xf7, 0x0f, 0x00, 0x00, 0x44, 0x45, 0x34, 0xbf, 0xb8, 0x00,
            0x10, 0xf0, 0x08, 0xf4, 0x18, 0x11, 0xfc, 0x18, 0xfb, 0x0e, 0x10, 0xf8, 0x04, 0xf8, 0x10, 0x20,
            0x18, 0x09, 0xff, 0x0c, 0xea, 0x1f, 0x28, 0x60, 0x30, 0xf8, 0x20, 0xc0, 0x42, 0x33, 0x21, 0x00
        };

        // clang-format on
        oled_write_raw_P(aurora_art, sizeof(aurora_art));
    }

    // oled_render();
    return false;
}

// syncing data
// look for https://github.com/qmk/qmk_firmware/blob/master/keyboards/tzarc/djinn/graphics/theme_djinn_default.c#L277
void rpc_ram_usage_sync_callback(uint8_t m2s_size, const void *m2s_buffer, uint8_t s2m_size, void *s2m_buffer) {
    if (m2s_size == sizeof(free_ram_state)) {
        memcpy(&free_ram_state, m2s_buffer, m2s_size);
    }
}

void display_mode_sync_callback(uint8_t m2s_size, const void *m2s_buffer, uint8_t s2m_size, void *s2m_buffer) {
    if (m2s_size == sizeof(display_mode_state)) {
        memcpy(&display_mode_state, m2s_buffer, m2s_size);
    }
}

void keyboard_post_init_user(void) {
    transaction_register_rpc(RAM_USAGE_DATA_SYNC, rpc_ram_usage_sync_callback);
    transaction_register_rpc(DISPLAY_MODE_SYNC, display_mode_sync_callback);

    // Reset the initial shared data value between master and slave
    memset(&free_ram_state, 0, sizeof(free_ram_state));
    memset(&display_mode_state, 0, sizeof(display_mode_state));
}

void housekeeping_task_user(void) {
    // keep data to slave in sync
    if (is_keyboard_master()) {
        free_ram_state.m2s_data = free_ram;
        display_mode_state.m2s_data = display_mode;
    } else {
        display_mode = (uint8_t) display_mode_state.m2s_data;
    }

    if (is_keyboard_master() && is_transport_connected()) {
        // Keep track of the last state, so that we can tell if we need to propagate to slave
        static master_to_slave_t    last_free_ram_state;
        static master_to_slave_t    last_display_mode_state;
        static uint32_t             last_sync;
        bool                        needs_sync = false;
        bool                        needs_sync_display_mode = false;

        // Check if the free ram values are different
        if (memcmp(&free_ram_state, &last_free_ram_state, sizeof(master_to_slave_t))) {
            needs_sync = true;
            memcpy(&last_free_ram_state, &free_ram_state, sizeof(master_to_slave_t));
        }

        // check if the display mode is different
        if (memcmp(&display_mode_state, &last_display_mode_state, sizeof(master_to_slave_t))) {
            needs_sync_display_mode = true;
            memcpy(&last_display_mode_state, &display_mode_state, sizeof(master_to_slave_t));
        }

        // Send to slave every 500ms regardless of state change
        if (timer_elapsed32(last_sync) > 500) {
            needs_sync = true;
        }

        // Perform the sync if requested
        if (needs_sync) {
            if (transaction_rpc_send(RAM_USAGE_DATA_SYNC, sizeof(master_to_slave_t), &free_ram_state)) {
                last_sync = timer_read32();
            } else {
                dprint("Failed to perform rpc call\n");
            }
        }

        if (needs_sync_display_mode) {
            if (transaction_rpc_send(DISPLAY_MODE_SYNC, sizeof(master_to_slave_t), &display_mode_state)) {
                last_sync = timer_read32();
            } else {
                dprint("Failed to perform rpc call\n");
            }
        }
    }
}
